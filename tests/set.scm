; Representing Sets

; tree node operate
(define (make-tree entry left right)
  (list entry left right))
(define (entry tree)
  (car tree))
(define (left-branch tree)
  (car (cdr tree)))
(define (right-branch tree)
  (car (cdr (cdr tree))))
; set operate
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (entry set)) true)
        ((< x (entry set))
         (element-of-set? x (left-branch set)))
        ((> x (entry set))
         (element-of-set? x (right-branch set)))))
(define (adjoint-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set))
         (make-tree (entry set)
                    (adjoint-set x (left-branch set))
                    (right-branch set)))
        ((> x (entry set))
         (make-tree (entry set)
                    (left-branch set)
                    (adjoint-set x (right-branch set))))))
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree) (tree->list-1 (right-branch tree))))))
(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree)
                                          result-list)))))
  (copy-to-list tree '()))
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts) right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry left-tree right-tree) remaining-elts))))))))
; union-set
(define (union-set a b)
  (define (union-list la lb)
    (cond ((and (null? la) (null? lb)) null)
          ((and (null? la) (pair? lb)) lb)
          ((and (pair? la) (null? lb)) la)
          (else
           (let ((ea (car la))
                 (eb (car lb)))
             (cond ((= ea eb) (cons ea (union-list (cdr la) (cdr lb))))
                   ((< ea eb) (cons ea (union-list (cdr la) lb)))
                   ((> ea eb) (cons eb (union-list la (cdr lb)))))))))
  (list->tree (union-list (tree->list-1 a)
                          (tree->list-1 b))))
; intersection
(define (intersection-set a b)
  (define (intersection-list la lb)
    (if (or (null? la) (null? lb))
        null
        (let ((ea (car la))
              (eb (car lb)))
          (cond ((= ea eb) (cons ea (intersection-list (cdr la) (cdr lb))))
                ((< ea eb) (intersection-list (cdr la) lb))
                ((> ea eb) (intersection-list la (cdr lb)))))))
  (list->tree (intersection-list (tree->list-1 a)
                                 (tree->list-1 b))))
; test
(define m (list->tree (list 1 2 3 4 5)))
(define n (list->tree (list 1 3 5 7 9)))
(tree->list-1 m)
(tree->list-1 n)
(tree->list-1 (union-set m n))
(tree->list-1 (intersection-set m n))
